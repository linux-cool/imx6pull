# WiFi/è“ç‰™æ·±åº¦å®è·µé¡¹ç›®è§„åˆ’

## é¡¹ç›®æ¦‚è¿°

åŸºäºIMX6ULL Proå¼€å‘æ¿ï¼Œè§„åˆ’ä¸€ä¸ªæ·±åº¦WiFi/è“ç‰™å®è·µé¡¹ç›®ï¼Œæ—¢èƒ½æ·±å…¥ç†è§£æŠ€æœ¯åŸç†ï¼Œåˆèƒ½åœ¨ä¼ä¸šä¸­æœ‰å®é™…åº”ç”¨ä»·å€¼ã€‚

### ğŸ¯ é¡¹ç›®ç›®æ ‡
- **æŠ€æœ¯æ·±åº¦**ï¼šç†è§£WiFi/è“ç‰™åè®®æ ˆã€é©±åŠ¨æ¶æ„ã€ç½‘ç»œç¼–ç¨‹
- **åº”ç”¨å¹¿åº¦**ï¼šè¦†ç›–ä¼ä¸šçº§åº”ç”¨åœºæ™¯ï¼Œå…·å¤‡å•†ä¸šåŒ–ä»·å€¼
- **æŠ€èƒ½æå‡**ï¼šæŒæ¡åµŒå…¥å¼ç½‘ç»œå¼€å‘ã€åè®®è®¾è®¡ã€ç³»ç»Ÿé›†æˆ

---

## ğŸ—ï¸ é¡¹ç›®æ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åº”ç”¨å±‚ (Application Layer)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Webç®¡ç†ç•Œé¢  â”‚  ç§»åŠ¨ç«¯APP  â”‚  äº‘ç«¯æœåŠ¡  â”‚  æ•°æ®åˆ†æå¹³å°    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ä¸šåŠ¡é€»è¾‘å±‚ (Business Logic)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è®¾å¤‡ç®¡ç†  â”‚  ç”¨æˆ·è®¤è¯  â”‚  æ•°æ®åŒæ­¥  â”‚  è¿œç¨‹æ§åˆ¶  â”‚  å‘Šè­¦ç³»ç»Ÿ  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ç½‘ç»œåè®®å±‚ (Network Protocol)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  HTTP/HTTPS  â”‚  MQTT  â”‚  WebSocket  â”‚  CoAP  â”‚  è‡ªå®šä¹‰åè®®  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ä¼ è¾“å±‚ (Transport Layer)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  TCP/UDP  â”‚  WiFi  â”‚  è“ç‰™  â”‚  ä»¥å¤ªç½‘  â”‚  4Gæ¨¡å—          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ç¡¬ä»¶æŠ½è±¡å±‚ (Hardware Abstraction)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  WiFié©±åŠ¨  â”‚  è“ç‰™é©±åŠ¨  â”‚  ä¼ æ„Ÿå™¨é©±åŠ¨  â”‚  å­˜å‚¨é©±åŠ¨        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ç¡¬ä»¶å±‚ (Hardware Layer)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  IMX6ULL Pro  â”‚  WiFiæ¨¡å—  â”‚  è“ç‰™æ¨¡å—  â”‚  ä¼ æ„Ÿå™¨  â”‚  å­˜å‚¨    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸš€ é¡¹ç›®åŠŸèƒ½æ¨¡å—

### 1. æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

#### WiFiç®¡ç†æ¨¡å—
- **WiFiå®¢æˆ·ç«¯æ¨¡å¼**ï¼šè¿æ¥ä¼ä¸šWiFiç½‘ç»œ
- **WiFiçƒ­ç‚¹æ¨¡å¼**ï¼šåˆ›å»ºä¸´æ—¶ç½‘ç»œ
- **WiFiä¸­ç»§æ¨¡å¼**ï¼šæ‰©å±•ç½‘ç»œè¦†ç›–
- **ç½‘ç»œè´¨é‡ç›‘æ§**ï¼šä¿¡å·å¼ºåº¦ã€å¸¦å®½ã€å»¶è¿Ÿæ£€æµ‹
- **å®‰å…¨è®¤è¯**ï¼šWPA2/WPA3ã€ä¼ä¸šçº§è®¤è¯

#### è“ç‰™ç®¡ç†æ¨¡å—
- **ç»å…¸è“ç‰™**ï¼šæ–‡ä»¶ä¼ è¾“ã€éŸ³é¢‘ä¼ è¾“
- **ä½åŠŸè€—è“ç‰™(BLE)**ï¼šä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ã€è®¾å¤‡æ§åˆ¶
- **è“ç‰™Mesh**ï¼šå¤šè®¾å¤‡ç»„ç½‘
- **è®¾å¤‡å‘ç°**ï¼šè‡ªåŠ¨æ‰«æå’Œé…å¯¹
- **å®‰å…¨é…å¯¹**ï¼šPINç ã€OOBè®¤è¯

#### è®¾å¤‡ç®¡ç†æ¨¡å—
- **è®¾å¤‡æ³¨å†Œ**ï¼šå”¯ä¸€æ ‡è¯†ã€è®¤è¯ä¿¡æ¯
- **çŠ¶æ€ç›‘æ§**ï¼šåœ¨çº¿çŠ¶æ€ã€å¥åº·æ£€æŸ¥
- **è¿œç¨‹é…ç½®**ï¼šå‚æ•°è®¾ç½®ã€å›ºä»¶å‡çº§
- **æƒé™ç®¡ç†**ï¼šç”¨æˆ·è§’è‰²ã€è®¿é—®æ§åˆ¶

#### æ•°æ®ç®¡ç†æ¨¡å—
- **æœ¬åœ°å­˜å‚¨**ï¼šSQLiteæ•°æ®åº“ã€æ–‡ä»¶ç³»ç»Ÿ
- **æ•°æ®åŒæ­¥**ï¼šå¢é‡åŒæ­¥ã€å†²çªè§£å†³
- **æ•°æ®åŠ å¯†**ï¼šAESåŠ å¯†ã€æ•°å­—ç­¾å
- **å¤‡ä»½æ¢å¤**ï¼šè‡ªåŠ¨å¤‡ä»½ã€ç¾éš¾æ¢å¤

### 2. ä¼ä¸šåº”ç”¨æ¨¡å—

#### å·¥ä¸šç‰©è”ç½‘ç½‘å…³
- **è®¾å¤‡æ¥å…¥**ï¼šæ”¯æŒå¤šç§å·¥ä¸šåè®®(Modbusã€CANã€Profibus)
- **æ•°æ®é‡‡é›†**ï¼šå®æ—¶æ•°æ®é‡‡é›†ã€å†å²æ•°æ®å­˜å‚¨
- **è¾¹ç¼˜è®¡ç®—**ï¼šæœ¬åœ°æ•°æ®å¤„ç†ã€AIæ¨ç†
- **äº‘ç«¯åŒæ­¥**ï¼šæ•°æ®ä¸Šä¼ ã€é…ç½®ä¸‹å‘

#### æ™ºèƒ½åŠå…¬ç³»ç»Ÿ
- **ä¼šè®®å®¤ç®¡ç†**ï¼šé¢„çº¦ã€ç­¾åˆ°ã€è®¾å¤‡æ§åˆ¶
- **è®¿å®¢ç®¡ç†**ï¼šèº«ä»½éªŒè¯ã€æƒé™æ§åˆ¶ã€è½¨è¿¹è·Ÿè¸ª
- **ç¯å¢ƒç›‘æ§**ï¼šæ¸©æ¹¿åº¦ã€ç©ºæ°”è´¨é‡ã€å…‰ç…§æ£€æµ‹
- **èƒ½è€—ç®¡ç†**ï¼šç”¨ç”µç›‘æ§ã€èŠ‚èƒ½æ§åˆ¶

#### é›¶å”®è§£å†³æ–¹æ¡ˆ
- **å•†å“ç®¡ç†**ï¼šåº“å­˜ç›‘æ§ã€ä»·æ ¼ç®¡ç†
- **å®¢æˆ·æœåŠ¡**ï¼šæ™ºèƒ½å¯¼è´­ã€ä¸ªæ€§åŒ–æ¨è
- **æ”¯ä»˜é›†æˆ**ï¼šç§»åŠ¨æ”¯ä»˜ã€ä¼šå‘˜ç®¡ç†
- **æ•°æ®åˆ†æ**ï¼šé”€å”®ç»Ÿè®¡ã€å®¢æˆ·è¡Œä¸ºåˆ†æ

---

## ğŸ› ï¸ æŠ€æœ¯å®ç°æ–¹æ¡ˆ

### 1. WiFiæŠ€æœ¯å®ç°

#### é©±åŠ¨å±‚å¼€å‘

```c
// WiFié©±åŠ¨æ¥å£
struct wifi_driver {
    int (*init)(void);
    int (*connect)(const char *ssid, const char *password);
    int (*disconnect)(void);
    int (*get_status)(wifi_status_t *status);
    int (*scan_networks)(wifi_network_t *networks, int max_count);
    int (*set_mode)(wifi_mode_t mode);
};

// WiFiçŠ¶æ€ç›‘æ§
typedef struct {
    wifi_connection_state_t state;
    int signal_strength;
    int channel;
    char ssid[32];
    wifi_security_t security;
} wifi_status_t;
```

#### ç½‘ç»œé…ç½®ç®¡ç†

```bash
# WiFié…ç½®æ–‡ä»¶ç¤ºä¾‹
network={
    ssid="Enterprise_WiFi"
    key_mgmt=IEEE8021X
    eap=PEAP
    identity="username"
    password="password"
    phase2="auth=MSCHAPV2"
}

# ç½‘ç»œç®¡ç†è„šæœ¬
#!/bin/bash
# è‡ªåŠ¨è¿æ¥æœ€ä½³WiFiç½‘ç»œ
wifi_auto_connect() {
    local best_network=""
    local best_signal=-100
    
    for network in $(iwlist wlan0 scan | grep ESSID); do
        local signal=$(iwlist wlan0 scan | grep -A 5 "$network" | grep Quality | cut -d= -f2 | cut -d' ' -f1)
        if [ $signal -gt $best_signal ]; then
            best_signal=$signal
            best_network=$network
        fi
    done
    
    if [ -n "$best_network" ]; then
        wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf
    fi
}
```

### 2. è“ç‰™æŠ€æœ¯å®ç°

#### BLEæœåŠ¡å¼€å‘

```c
// è‡ªå®šä¹‰BLEæœåŠ¡
#define CUSTOM_SERVICE_UUID    0x1800
#define CUSTOM_CHAR_UUID      0x2A00

// æœåŠ¡å®šä¹‰
static const struct bt_gatt_attr custom_attrs[] = {
    BT_GATT_PRIMARY_SERVICE(BT_UUID_DECLARE_16(CUSTOM_SERVICE_UUID)),
    BT_GATT_CHARACTERISTIC(BT_UUID_DECLARE_16(CUSTOM_CHAR_UUID),
                           BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE,
                           BT_GATT_PERM_READ | BT_GATT_PERM_WRITE,
                           custom_read, custom_write, NULL),
    BT_GATT_CCC(NULL, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE),
};

// æ•°æ®è¯»å†™å›è°ƒ
static ssize_t custom_read(struct bt_conn *conn,
                           const struct bt_gatt_attr *attr,
                           void *buf, uint16_t len, uint16_t offset)
{
    // å®ç°æ•°æ®è¯»å–é€»è¾‘
    return bt_gatt_attr_read(conn, attr, buf, len, offset, data, data_len);
}

static ssize_t custom_write(struct bt_conn *conn,
                            const struct bt_gatt_attr *attr,
                            const void *buf, uint16_t len, uint16_t offset,
                            uint8_t flags)
{
    // å®ç°æ•°æ®å†™å…¥é€»è¾‘
    return len;
}
```

#### è“ç‰™è®¾å¤‡ç®¡ç†

```c
// è®¾å¤‡ç®¡ç†ç»“æ„
typedef struct {
    bt_addr_le_t addr;
    char name[32];
    uint8_t rssi;
    uint8_t flags;
    uint16_t appearance;
    uint8_t data_len;
    uint8_t data[31];
} ble_device_info_t;

// è®¾å¤‡æ‰«æ
static void scan_cb(const bt_addr_le_t *addr, int8_t rssi, uint8_t adv_type,
                    struct net_buf_simple *buf)
{
    char addr_str[BT_ADDR_LE_STR_LEN];
    bt_addr_le_to_str(addr, addr_str, sizeof(addr_str));
    
    printk("Found device: %s (RSSI: %d)\n", addr_str, rssi);
    
    // å­˜å‚¨è®¾å¤‡ä¿¡æ¯
    store_device_info(addr, rssi, buf);
}
```

### 3. ç½‘ç»œåè®®å®ç°

#### MQTTå®¢æˆ·ç«¯

```c
// MQTTå®¢æˆ·ç«¯é…ç½®
struct mqtt_client_config {
    char *broker_url;
    int port;
    char *client_id;
    char *username;
    char *password;
    int keepalive;
    int clean_session;
};

// MQTTæ¶ˆæ¯å¤„ç†
static void mqtt_message_callback(struct mqtt_client *client,
                                  const struct mqtt_conn *conn,
                                  const struct mqtt_publish *msg)
{
    if (msg->payload_len > 0) {
        // å¤„ç†æ¥æ”¶åˆ°çš„æ¶ˆæ¯
        process_mqtt_message(msg->topic, msg->payload, msg->payload_len);
    }
}

// å‘å¸ƒæ¶ˆæ¯
int mqtt_publish_message(const char *topic, const char *message, int qos)
{
    struct mqtt_publish_param param = {
        .message.topic.qos = qos,
        .message.payload.data = message,
        .message.payload.len = strlen(message),
        .message.topic.topic.utf8 = topic,
        .message.topic.topic.size = strlen(topic),
    };
    
    return mqtt_publish(client, &param);
}
```

#### HTTPæœåŠ¡å™¨

```c
// HTTPè·¯ç”±å¤„ç†
static const http_route_t routes[] = {
    {"/api/devices", HTTP_GET, handle_get_devices},
    {"/api/devices", HTTP_POST, handle_create_device},
    {"/api/devices/{id}", HTTP_GET, handle_get_device},
    {"/api/devices/{id}", HTTP_PUT, handle_update_device},
    {"/api/devices/{id}", HTTP_DELETE, handle_delete_device},
    {"/api/status", HTTP_GET, handle_get_status},
    {"/api/config", HTTP_GET, handle_get_config},
    {"/api/config", HTTP_POST, handle_update_config},
};

// è®¾å¤‡çŠ¶æ€API
static int handle_get_status(struct http_request *req, struct http_response *resp)
{
    cJSON *status = cJSON_CreateObject();
    
    // è·å–ç³»ç»ŸçŠ¶æ€
    cJSON_AddStringToObject(status, "wifi_status", get_wifi_status());
    cJSON_AddStringToObject(status, "bluetooth_status", get_bluetooth_status());
    cJSON_AddNumberToObject(status, "cpu_usage", get_cpu_usage());
    cJSON_AddNumberToObject(status, "memory_usage", get_memory_usage());
    cJSON_AddNumberToObject(status, "uptime", get_uptime());
    
    char *json_str = cJSON_Print(status);
    http_response_set_body(resp, json_str, strlen(json_str));
    
    cJSON_Delete(status);
    free(json_str);
    
    return 0;
}
```

---

## ğŸ“± ç§»åŠ¨ç«¯é›†æˆ

### React Nativeåº”ç”¨

```javascript
// è®¾å¤‡ç®¡ç†ç•Œé¢
import React, { useState, useEffect } from 'react';
import { View, Text, FlatList, TouchableOpacity, StyleSheet } from 'react-native';

const DeviceList = () => {
    const [devices, setDevices] = useState([]);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        fetchDevices();
    }, []);

    const fetchDevices = async () => {
        setLoading(true);
        try {
            const response = await fetch('http://192.168.1.100:8080/api/devices');
            const data = await response.json();
            setDevices(data);
        } catch (error) {
            console.error('Error fetching devices:', error);
        } finally {
            setLoading(false);
        }
    };

    const connectDevice = async (deviceId) => {
        try {
            const response = await fetch(`http://192.168.1.100:8080/api/devices/${deviceId}/connect`, {
                method: 'POST'
            });
            if (response.ok) {
                // è¿æ¥æˆåŠŸ
                fetchDevices(); // åˆ·æ–°è®¾å¤‡åˆ—è¡¨
            }
        } catch (error) {
            console.error('Error connecting device:', error);
        }
    };

    return (
        <View style={styles.container}>
            <Text style={styles.title}>è®¾å¤‡ç®¡ç†</Text>
            <FlatList
                data={devices}
                keyExtractor={(item) => item.id}
                renderItem={({ item }) => (
                    <View style={styles.deviceItem}>
                        <Text style={styles.deviceName}>{item.name}</Text>
                        <Text style={styles.deviceStatus}>{item.status}</Text>
                        <TouchableOpacity
                            style={styles.connectButton}
                            onPress={() => connectDevice(item.id)}
                        >
                            <Text style={styles.buttonText}>è¿æ¥</Text>
                        </TouchableOpacity>
                    </View>
                )}
            />
        </View>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
        padding: 20,
        backgroundColor: '#f5f5f5'
    },
    title: {
        fontSize: 24,
        fontWeight: 'bold',
        marginBottom: 20
    },
    deviceItem: {
        backgroundColor: 'white',
        padding: 15,
        marginBottom: 10,
        borderRadius: 8,
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between'
    },
    deviceName: {
        fontSize: 16,
        fontWeight: '500'
    },
    deviceStatus: {
        fontSize: 14,
        color: '#666'
    },
    connectButton: {
        backgroundColor: '#007AFF',
        paddingHorizontal: 15,
        paddingVertical: 8,
        borderRadius: 6
    },
    buttonText: {
        color: 'white',
        fontSize: 14
    }
});

export default DeviceList;
```

---

## â˜ï¸ äº‘ç«¯æœåŠ¡é›†æˆ

### æ•°æ®åŒæ­¥æœåŠ¡

```python
# Python Flaskåç«¯æœåŠ¡
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
import json

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///devices.db'
db = SQLAlchemy(app)

class Device(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    device_id = db.Column(db.String(64), unique=True, nullable=False)
    name = db.Column(db.String(128), nullable=False)
    type = db.Column(db.String(64), nullable=False)
    status = db.Column(db.String(32), default='offline')
    last_seen = db.Column(db.DateTime, default=datetime.utcnow)
    config = db.Column(db.Text, default='{}')
    
    def to_dict(self):
        return {
            'id': self.id,
            'device_id': self.device_id,
            'name': self.name,
            'type': self.type,
            'status': self.status,
            'last_seen': self.last_seen.isoformat(),
            'config': json.loads(self.config)
        }

@app.route('/api/devices', methods=['GET'])
def get_devices():
    devices = Device.query.all()
    return jsonify([device.to_dict() for device in devices])

@app.route('/api/devices', methods=['POST'])
def create_device():
    data = request.get_json()
    
    device = Device(
        device_id=data['device_id'],
        name=data['name'],
        type=data['type'],
        config=json.dumps(data.get('config', {}))
    )
    
    db.session.add(device)
    db.session.commit()
    
    return jsonify(device.to_dict()), 201

@app.route('/api/devices/<int:device_id>/status', methods=['PUT'])
def update_device_status(device_id):
    device = Device.query.get_or_404(device_id)
    data = request.get_json()
    
    device.status = data['status']
    device.last_seen = datetime.utcnow()
    
    db.session.commit()
    
    return jsonify(device.to_dict())

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True, host='0.0.0.0', port=5000)
```

---

## ğŸ“… é¡¹ç›®å¼€å‘è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€æ¶æ„ (4å‘¨)
- **Week 1-2**: ç¯å¢ƒæ­å»ºã€é©±åŠ¨å¼€å‘ã€åŸºç¡€åŠŸèƒ½æµ‹è¯•
- **Week 3-4**: WiFi/è“ç‰™åŸºç¡€åŠŸèƒ½å®ç°ã€ç½‘ç»œé…ç½®

#### 1.1 WiFié©±åŠ¨å¼€å‘è¯¦ç»†æ‹†è§£

##### 1.1.1 WiFié©±åŠ¨æ¶æ„è®¾è®¡
```c
// WiFié©±åŠ¨æ•´ä½“æ¶æ„
struct wifi_driver_ops {
    // åŸºç¡€æ“ä½œ
    int (*probe)(struct wifi_device *dev);
    int (*remove)(struct wifi_device *dev);
    int (*suspend)(struct wifi_device *dev);
    int (*resume)(struct wifi_device *dev);
    
    // WiFiåŠŸèƒ½æ“ä½œ
    int (*init)(struct wifi_device *dev);
    int (*deinit)(struct wifi_device *dev);
    int (*reset)(struct wifi_device *dev);
    
    // ç½‘ç»œç®¡ç†
    int (*scan_start)(struct wifi_device *dev);
    int (*scan_stop)(struct wifi_device *dev);
    int (*connect)(struct wifi_device *dev, struct wifi_connect_params *params);
    int (*disconnect)(struct wifi_device *dev);
    
    // çŠ¶æ€æŸ¥è¯¢
    int (*get_status)(struct wifi_device *dev, struct wifi_status *status);
    int (*get_signal_strength)(struct wifi_device *dev, int *strength);
    int (*get_connection_info)(struct wifi_device *dev, struct wifi_connection_info *info);
};

// WiFiè®¾å¤‡ç»“æ„
struct wifi_device {
    struct device *dev;
    struct wifi_driver_ops *ops;
    struct wifi_status status;
    struct wifi_connection_info conn_info;
    struct mutex lock;
    struct workqueue_struct *workqueue;
    struct delayed_work scan_work;
    struct delayed_work status_work;
    
    // ç¡¬ä»¶ç›¸å…³
    void *private_data;
    struct spi_device *spi;
    struct platform_device *pdev;
    
    // ç½‘ç»œç›¸å…³
    struct net_device *ndev;
    struct wireless_dev *wdev;
};
```

##### 1.1.2 WiFié©±åŠ¨åˆå§‹åŒ–æµç¨‹
```c
// WiFié©±åŠ¨åˆå§‹åŒ–
static int wifi_driver_probe(struct platform_device *pdev)
{
    struct wifi_device *wdev;
    struct wifi_platform_data *pdata;
    int ret;
    
    // 1. åˆ†é…è®¾å¤‡ç»“æ„
    wdev = devm_kzalloc(&pdev->dev, sizeof(*wdev), GFP_KERNEL);
    if (!wdev)
        return -ENOMEM;
    
    // 2. è·å–å¹³å°æ•°æ®
    pdata = dev_get_platdata(&pdev->dev);
    if (!pdata) {
        dev_err(&pdev->dev, "No platform data\n");
        return -EINVAL;
    }
    
    // 3. åˆå§‹åŒ–è®¾å¤‡
    wdev->dev = &pdev->dev;
    wdev->pdev = pdev;
    wdev->ops = &wifi_driver_ops;
    
    // 4. åˆå§‹åŒ–äº’æ–¥é”
    mutex_init(&wdev->lock);
    
    // 5. åˆ›å»ºå·¥ä½œé˜Ÿåˆ—
    wdev->workqueue = create_singlethread_workqueue("wifi_workqueue");
    if (!wdev->workqueue) {
        ret = -ENOMEM;
        goto err_workqueue;
    }
    
    // 6. åˆå§‹åŒ–å·¥ä½œé¡¹
    INIT_DELAYED_WORK(&wdev->scan_work, wifi_scan_work);
    INIT_DELAYED_WORK(&wdev->status_work, wifi_status_work);
    
    // 7. æ³¨å†Œç½‘ç»œè®¾å¤‡
    ret = wifi_register_netdev(wdev);
    if (ret)
        goto err_netdev;
    
    // 8. æ³¨å†Œæ— çº¿è®¾å¤‡
    ret = wifi_register_wireless_dev(wdev);
    if (ret)
        goto err_wireless;
    
    // 9. è®¾ç½®å¹³å°æ•°æ®
    platform_set_drvdata(pdev, wdev);
    
    // 10. åˆå§‹åŒ–ç¡¬ä»¶
    ret = wdev->ops->init(wdev);
    if (ret)
        goto err_init;
    
    dev_info(&pdev->dev, "WiFi driver probed successfully\n");
    return 0;
    
err_init:
    wifi_unregister_wireless_dev(wdev);
err_wireless:
    wifi_unregister_netdev(wdev);
err_netdev:
    destroy_workqueue(wdev->workqueue);
err_workqueue:
    mutex_destroy(&wdev->lock);
    return ret;
}
```

##### 1.1.3 WiFiæ‰«æåŠŸèƒ½å®ç°
```c
// WiFiæ‰«æå·¥ä½œå‡½æ•°
static void wifi_scan_work(struct work_struct *work)
{
    struct wifi_device *wdev = container_of(to_delayed_work(work),
                                           struct wifi_device, scan_work);
    struct wifi_scan_result *results;
    int num_results;
    
    mutex_lock(&wdev->lock);
    
    // 1. å¯åŠ¨ç¡¬ä»¶æ‰«æ
    if (wdev->ops->scan_start(wdev) < 0) {
        dev_err(wdev->dev, "Failed to start scan\n");
        mutex_unlock(&wdev->lock);
        return;
    }
    
    // 2. ç­‰å¾…æ‰«æå®Œæˆ
    msleep(5000); // ç­‰å¾…5ç§’
    
    // 3. è·å–æ‰«æç»“æœ
    num_results = wifi_get_scan_results(wdev, &results);
    if (num_results > 0) {
        // 4. å¤„ç†æ‰«æç»“æœ
        wifi_process_scan_results(wdev, results, num_results);
        kfree(results);
    }
    
    // 5. åœæ­¢æ‰«æ
    wdev->ops->scan_stop(wdev);
    
    mutex_unlock(&wdev->lock);
    
    // 6. å‘é€æ‰«æå®Œæˆäº‹ä»¶
    wifi_send_scan_complete_event(wdev);
}

// æ‰«æç»“æœå¤„ç†
static void wifi_process_scan_results(struct wifi_device *wdev,
                                     struct wifi_scan_result *results,
                                     int num_results)
{
    int i;
    struct wifi_network *network;
    
    for (i = 0; i < num_results; i++) {
        network = &results[i];
        
        // è¿‡æ»¤ä¿¡å·å¼ºåº¦
        if (network->signal_strength < -80)
            continue;
            
        // è¿‡æ»¤åŠ å¯†ç±»å‹
        if (network->security == WIFI_SECURITY_OPEN)
            continue;
            
        // æ·»åŠ åˆ°ç½‘ç»œåˆ—è¡¨
        wifi_add_network_to_list(wdev, network);
    }
}
```

##### 1.1.4 WiFiè¿æ¥ç®¡ç†
```c
// WiFiè¿æ¥å‚æ•°
struct wifi_connect_params {
    char ssid[IEEE80211_MAX_SSID_LEN];
    char password[64];
    enum wifi_security security;
    enum wifi_cipher cipher;
    int channel;
    bool hidden;
};

// WiFiè¿æ¥å®ç°
static int wifi_connect_network(struct wifi_device *wdev,
                               struct wifi_connect_params *params)
{
    int ret;
    struct wifi_connection_info *conn_info;
    
    mutex_lock(&wdev->lock);
    
    // 1. æ£€æŸ¥è®¾å¤‡çŠ¶æ€
    if (wdev->status.state != WIFI_STATE_READY) {
        ret = -EBUSY;
        goto out;
    }
    
    // 2. éªŒè¯è¿æ¥å‚æ•°
    ret = wifi_validate_connect_params(params);
    if (ret < 0)
        goto out;
    
    // 3. è®¾ç½®è¿æ¥çŠ¶æ€
    wdev->status.state = WIFI_STATE_CONNECTING;
    
    // 4. è°ƒç”¨ç¡¬ä»¶è¿æ¥
    ret = wdev->ops->connect(wdev, params);
    if (ret < 0) {
        wdev->status.state = WIFI_STATE_READY;
        goto out;
    }
    
    // 5. ç­‰å¾…è¿æ¥å®Œæˆ
    ret = wait_for_completion_timeout(&wdev->connect_completion, 30000);
    if (ret == 0) {
        // è¿æ¥è¶…æ—¶
        wdev->ops->disconnect(wdev);
        wdev->status.state = WIFI_STATE_READY;
        ret = -ETIMEDOUT;
        goto out;
    }
    
    // 6. æ›´æ–°è¿æ¥ä¿¡æ¯
    conn_info = &wdev->conn_info;
    strcpy(conn_info->ssid, params->ssid);
    conn_info->security = params->security;
    conn_info->channel = params->channel;
    conn_info->connected = true;
    
    // 7. æ›´æ–°è®¾å¤‡çŠ¶æ€
    wdev->status.state = WIFI_STATE_CONNECTED;
    
    // 8. å‘é€è¿æ¥æˆåŠŸäº‹ä»¶
    wifi_send_connection_event(wdev, WIFI_EVENT_CONNECTED);
    
    ret = 0;
    
out:
    mutex_unlock(&wdev->lock);
    return ret;
}
```

#### 1.2 è“ç‰™é©±åŠ¨å¼€å‘è¯¦ç»†æ‹†è§£

##### 1.2.1 è“ç‰™é©±åŠ¨æ¶æ„è®¾è®¡
```c
// è“ç‰™é©±åŠ¨æ“ä½œç»“æ„
struct bluetooth_driver_ops {
    // åŸºç¡€æ“ä½œ
    int (*probe)(struct bluetooth_device *bdev);
    int (*remove)(struct bluetooth_device *bdev);
    int (*suspend)(struct bluetooth_device *bdev);
    int (*resume)(struct bluetooth_device *bdev);
    
    // è“ç‰™åŠŸèƒ½æ“ä½œ
    int (*init)(struct bluetooth_device *bdev);
    int (*deinit)(struct bluetooth_device *bdev);
    int (*reset)(struct bluetooth_device *bdev);
    
    // ç»å…¸è“ç‰™æ“ä½œ
    int (*classic_scan_start)(struct bluetooth_device *bdev);
    int (*classic_scan_stop)(struct bluetooth_device *bdev);
    int (*classic_connect)(struct bluetooth_device *bdev, bdaddr_t *addr);
    int (*classic_disconnect)(struct bluetooth_device *bdev);
    
    // BLEæ“ä½œ
    int (*ble_scan_start)(struct bluetooth_device *bdev);
    int (*ble_scan_stop)(struct bluetooth_device *bdev);
    int (*ble_connect)(struct bluetooth_device *bdev, bdaddr_t *addr);
    int (*ble_disconnect)(struct bluetooth_device *bdev);
    
    // GATTæœåŠ¡æ“ä½œ
    int (*gatt_service_add)(struct bluetooth_device *bdev, struct gatt_service *service);
    int (*gatt_service_remove)(struct bluetooth_device *bdev, struct gatt_service *service);
};

// è“ç‰™è®¾å¤‡ç»“æ„
struct bluetooth_device {
    struct device *dev;
    struct bluetooth_driver_ops *ops;
    struct bluetooth_status status;
    struct bluetooth_connection_info conn_info;
    struct mutex lock;
    struct workqueue_struct *workqueue;
    struct delayed_work scan_work;
    struct delayed_work status_work;
    
    // ç¡¬ä»¶ç›¸å…³
    void *private_data;
    struct spi_device *spi;
    struct platform_device *pdev;
    
    // è“ç‰™ç›¸å…³
    struct hci_dev *hdev;
    struct l2cap_conn *l2cap_conn;
    
    // GATTæœåŠ¡
    struct list_head gatt_services;
    struct mutex gatt_lock;
};
```

##### 1.2.2 BLEæ‰«æåŠŸèƒ½å®ç°
```c
// BLEæ‰«æå·¥ä½œå‡½æ•°
static void ble_scan_work(struct work_struct *work)
{
    struct bluetooth_device *bdev = container_of(to_delayed_work(work),
                                                struct bluetooth_device, scan_work);
    struct ble_scan_result *results;
    int num_results;
    
    mutex_lock(&bdev->lock);
    
    // 1. å¯åŠ¨BLEæ‰«æ
    if (bdev->ops->ble_scan_start(bdev) < 0) {
        dev_err(bdev->dev, "Failed to start BLE scan\n");
        mutex_unlock(&bdev->lock);
        return;
    }
    
    // 2. ç­‰å¾…æ‰«æå®Œæˆ
    msleep(3000); // ç­‰å¾…3ç§’
    
    // 3. è·å–æ‰«æç»“æœ
    num_results = ble_get_scan_results(bdev, &results);
    if (num_results > 0) {
        // 4. å¤„ç†æ‰«æç»“æœ
        ble_process_scan_results(bdev, results, num_results);
        kfree(results);
    }
    
    // 5. åœæ­¢æ‰«æ
    bdev->ops->ble_scan_stop(bdev);
    
    mutex_unlock(&bdev->lock);
    
    // 6. å‘é€æ‰«æå®Œæˆäº‹ä»¶
    ble_send_scan_complete_event(bdev);
}

// BLEæ‰«æç»“æœå¤„ç†
static void ble_process_scan_results(struct bluetooth_device *bdev,
                                    struct ble_scan_result *results,
                                    int num_results)
{
    int i;
    struct ble_device *device;
    
    for (i = 0; i < num_results; i++) {
        device = &results[i];
        
        // è¿‡æ»¤ä¿¡å·å¼ºåº¦
        if (device->rssi < -80)
            continue;
            
        // è¿‡æ»¤è®¾å¤‡ç±»å‹
        if (device->appearance != BLE_APPEARANCE_GENERIC_SENSOR)
            continue;
            
        // æ·»åŠ åˆ°è®¾å¤‡åˆ—è¡¨
        ble_add_device_to_list(bdev, device);
    }
}
```

##### 1.2.3 GATTæœåŠ¡å®ç°
```c
// GATTæœåŠ¡ç»“æ„
struct gatt_service {
    struct list_head list;
    uuid_t uuid;
    bool primary;
    struct list_head characteristics;
    struct gatt_service_ops *ops;
    void *private_data;
};

// GATTç‰¹å¾ç»“æ„
struct gatt_characteristic {
    struct list_head list;
    uuid_t uuid;
    uint8_t properties;
    uint8_t permissions;
    uint16_t value_handle;
    uint16_t ccc_handle;
    struct gatt_char_ops *ops;
    void *private_data;
};

// GATTæœåŠ¡æ·»åŠ 
static int gatt_service_add(struct bluetooth_device *bdev,
                           struct gatt_service *service)
{
    int ret;
    
    mutex_lock(&bdev->gatt_lock);
    
    // 1. éªŒè¯æœåŠ¡å‚æ•°
    ret = gatt_validate_service(service);
    if (ret < 0)
        goto out;
    
    // 2. æ·»åŠ åˆ°æœåŠ¡åˆ—è¡¨
    list_add_tail(&service->list, &bdev->gatt_services);
    
    // 3. æ³¨å†Œåˆ°è“ç‰™åè®®æ ˆ
    ret = gatt_register_service(bdev, service);
    if (ret < 0) {
        list_del(&service->list);
        goto out;
    }
    
    // 4. åˆå§‹åŒ–æœåŠ¡
    if (service->ops && service->ops->init) {
        ret = service->ops->init(service);
        if (ret < 0) {
            gatt_unregister_service(bdev, service);
            list_del(&service->list);
            goto out;
        }
    }
    
    ret = 0;
    
out:
    mutex_unlock(&bdev->gatt_lock);
    return ret;
}
```

#### 1.3 ç”¨æˆ·ç©ºé—´APPå¼€å‘è¯¦ç»†æ‹†è§£

##### 1.3.1 WiFiç®¡ç†APPæ¶æ„
```c
// WiFiç®¡ç†APPä¸»ç»“æ„
struct wifi_manager_app {
    struct wifi_device *wifi_dev;
    struct wifi_network_list *network_list;
    struct wifi_connection *current_connection;
    struct wifi_config *config;
    
    // ç”¨æˆ·ç•Œé¢
    struct wifi_ui *ui;
    struct wifi_settings *settings;
    
    // äº‹ä»¶å¤„ç†
    struct wifi_event_handler *event_handler;
    struct wifi_callback *callback;
    
    // æ•°æ®å­˜å‚¨
    struct wifi_database *database;
    struct wifi_logger *logger;
};

// WiFiç½‘ç»œåˆ—è¡¨ç®¡ç†
struct wifi_network_list {
    struct list_head networks;
    int count;
    struct mutex lock;
    
    // æ‰«æçŠ¶æ€
    bool scanning;
    struct completion scan_completion;
    
    // ç½‘ç»œè¿‡æ»¤
    struct wifi_filter *filter;
};

// WiFiç½‘ç»œä¿¡æ¯
struct wifi_network {
    struct list_head list;
    char ssid[IEEE80211_MAX_SSID_LEN];
    enum wifi_security security;
    enum wifi_cipher cipher;
    int signal_strength;
    int channel;
    int frequency;
    bool hidden;
    bool connected;
    
    // è¿æ¥å†å²
    time_t last_connected;
    int connection_count;
    int success_rate;
};
```

##### 1.3.2 WiFiç½‘ç»œæ‰«æAPPå®ç°
```c
// WiFiæ‰«æAPPå®ç°
static int wifi_scan_app_start(struct wifi_manager_app *app)
{
    int ret;
    struct wifi_network_list *network_list = app->network_list;
    
    // 1. æ£€æŸ¥æ‰«æçŠ¶æ€
    if (network_list->scanning) {
        return -EBUSY;
    }
    
    // 2. è®¾ç½®æ‰«æçŠ¶æ€
    network_list->scanning = true;
    init_completion(&network_list->scan_completion);
    
    // 3. æ¸…ç©ºç½‘ç»œåˆ—è¡¨
    wifi_clear_network_list(network_list);
    
    // 4. å¯åŠ¨ç¡¬ä»¶æ‰«æ
    ret = wifi_start_scan(app->wifi_dev);
    if (ret < 0) {
        network_list->scanning = false;
        return ret;
    }
    
    // 5. å¯åŠ¨æ‰«æè¶…æ—¶å®šæ—¶å™¨
    mod_timer(&app->scan_timer, jiffies + msecs_to_jiffies(30000));
    
    // 6. å‘é€æ‰«æå¼€å§‹äº‹ä»¶
    wifi_send_ui_event(app, WIFI_UI_EVENT_SCAN_STARTED);
    
    return 0;
}

// WiFiæ‰«æç»“æœå¤„ç†APP
static int wifi_scan_app_process_results(struct wifi_manager_app *app,
                                        struct wifi_scan_result *results,
                                        int num_results)
{
    int i;
    struct wifi_network *network;
    struct wifi_network_list *network_list = app->network_list;
    
    mutex_lock(&network_list->lock);
    
    for (i = 0; i < num_results; i++) {
        // 1. åˆ›å»ºç½‘ç»œå¯¹è±¡
        network = wifi_create_network(&results[i]);
        if (!network)
            continue;
        
        // 2. åº”ç”¨è¿‡æ»¤å™¨
        if (wifi_apply_filter(network, network_list->filter) < 0) {
            wifi_destroy_network(network);
            continue;
        }
        
        // 3. æ·»åŠ åˆ°ç½‘ç»œåˆ—è¡¨
        list_add_tail(&network->list, &network_list->networks);
        network_list->count++;
        
        // 4. æ›´æ–°UI
        wifi_update_ui_network(app, network);
    }
    
    mutex_unlock(&network_list->lock);
    
    // 5. å‘é€æ‰«æå®Œæˆäº‹ä»¶
    wifi_send_ui_event(app, WIFI_UI_EVENT_SCAN_COMPLETED);
    
    return 0;
}
```

##### 1.3.3 è“ç‰™è®¾å¤‡ç®¡ç†APPæ¶æ„
```c
// è“ç‰™ç®¡ç†APPä¸»ç»“æ„
struct bluetooth_manager_app {
    struct bluetooth_device *bt_dev;
    struct bluetooth_device_list *device_list;
    struct bluetooth_connection *current_connection;
    struct bluetooth_config *config;
    
    // ç”¨æˆ·ç•Œé¢
    struct bluetooth_ui *ui;
    struct bluetooth_settings *settings;
    
    // äº‹ä»¶å¤„ç†
    struct bluetooth_event_handler *event_handler;
    struct bluetooth_callback *callback;
    
    // æ•°æ®å­˜å‚¨
    struct bluetooth_database *database;
    struct bluetooth_logger *logger;
    
    // GATTæœåŠ¡ç®¡ç†
    struct gatt_service_manager *gatt_manager;
};

// è“ç‰™è®¾å¤‡åˆ—è¡¨ç®¡ç†
struct bluetooth_device_list {
    struct list_head devices;
    int count;
    struct mutex lock;
    
    // æ‰«æçŠ¶æ€
    bool scanning;
    struct completion scan_completion;
    
    // è®¾å¤‡è¿‡æ»¤
    struct bluetooth_filter *filter;
    
    // è®¾å¤‡åˆ†ç±»
    struct list_head classic_devices;
    struct list_head ble_devices;
    struct list_head paired_devices;
};

// è“ç‰™è®¾å¤‡ä¿¡æ¯
struct bluetooth_device_info {
    struct list_head list;
    bdaddr_t addr;
    char name[32];
    uint8_t device_class[3];
    uint8_t rssi;
    uint8_t flags;
    uint16_t appearance;
    
    // è¿æ¥çŠ¶æ€
    bool connected;
    bool paired;
    bool trusted;
    
    // æœåŠ¡ä¿¡æ¯
    struct list_head services;
    int service_count;
    
    // è¿æ¥å†å²
    time_t last_connected;
    int connection_count;
    int success_rate;
};
```

##### 1.3.4 è“ç‰™è®¾å¤‡æ‰«æAPPå®ç°
```c
// è“ç‰™æ‰«æAPPå®ç°
static int bluetooth_scan_app_start(struct bluetooth_manager_app *app)
{
    int ret;
    struct bluetooth_device_list *device_list = app->device_list;
    
    // 1. æ£€æŸ¥æ‰«æçŠ¶æ€
    if (device_list->scanning) {
        return -EBUSY;
    }
    
    // 2. è®¾ç½®æ‰«æçŠ¶æ€
    device_list->scanning = true;
    init_completion(&device_list->scan_completion);
    
    // 3. æ¸…ç©ºè®¾å¤‡åˆ—è¡¨
    bluetooth_clear_device_list(device_list);
    
    // 4. å¯åŠ¨ç»å…¸è“ç‰™æ‰«æ
    ret = bluetooth_start_classic_scan(app->bt_dev);
    if (ret < 0) {
        device_list->scanning = false;
        return ret;
    }
    
    // 5. å¯åŠ¨BLEæ‰«æ
    ret = bluetooth_start_ble_scan(app->bt_dev);
    if (ret < 0) {
        bluetooth_stop_classic_scan(app->bt_dev);
        device_list->scanning = false;
        return ret;
    }
    
    // 6. å¯åŠ¨æ‰«æè¶…æ—¶å®šæ—¶å™¨
    mod_timer(&app->scan_timer, jiffies + msecs_to_jiffies(20000));
    
    // 7. å‘é€æ‰«æå¼€å§‹äº‹ä»¶
    bluetooth_send_ui_event(app, BT_UI_EVENT_SCAN_STARTED);
    
    return 0;
}

// è“ç‰™è®¾å¤‡å‘ç°å¤„ç†APP
static int bluetooth_device_discovered(struct bluetooth_manager_app *app,
                                      struct bluetooth_device_info *device)
{
    struct bluetooth_device_list *device_list = app->device_list;
    
    mutex_lock(&device_list->lock);
    
    // 1. æ£€æŸ¥è®¾å¤‡æ˜¯å¦å·²å­˜åœ¨
    if (bluetooth_find_device(device_list, &device->addr)) {
        mutex_unlock(&device_list->lock);
        return 0;
    }
    
    // 2. åº”ç”¨è¿‡æ»¤å™¨
    if (bluetooth_apply_filter(device, device_list->filter) < 0) {
        mutex_unlock(&device_list->lock);
        return 0;
    }
    
    // 3. æ·»åŠ åˆ°è®¾å¤‡åˆ—è¡¨
    if (device->flags & BT_DEVICE_FLAG_LE) {
        list_add_tail(&device->list, &device_list->ble_devices);
    } else {
        list_add_tail(&device->list, &device_list->classic_devices);
    }
    device_list->count++;
    
    // 4. æ›´æ–°UI
    bluetooth_update_ui_device(app, device);
    
    mutex_unlock(&device_list->lock);
    
    // 5. å‘é€è®¾å¤‡å‘ç°äº‹ä»¶
    bluetooth_send_ui_event(app, BT_UI_EVENT_DEVICE_DISCOVERED);
    
    return 0;
}
```

#### 1.4 ç½‘ç»œé…ç½®ç®¡ç†è¯¦ç»†æ‹†è§£

##### 1.4.1 WiFiç½‘ç»œé…ç½®ç®¡ç†
```c
// WiFiç½‘ç»œé…ç½®ç»“æ„
struct wifi_network_config {
    char ssid[IEEE80211_MAX_SSID_LEN];
    enum wifi_security security;
    enum wifi_cipher cipher;
    char password[64];
    char identity[64];  // ä¼ä¸šçº§è®¤è¯
    char ca_cert[256];  // CAè¯ä¹¦è·¯å¾„
    char client_cert[256]; // å®¢æˆ·ç«¯è¯ä¹¦è·¯å¾„
    char private_key[256]; // ç§é’¥è·¯å¾„
    
    // é«˜çº§é…ç½®
    int channel;
    bool hidden;
    int priority;
    bool auto_connect;
    
    // ä¼ä¸šçº§é…ç½®
    enum wifi_eap_method eap_method;
    char phase2_auth[32];
    char anonymous_identity[64];
};

// WiFié…ç½®ç®¡ç†APP
static int wifi_config_app_save_network(struct wifi_manager_app *app,
                                       struct wifi_network_config *config)
{
    int ret;
    struct wifi_database *database = app->database;
    
    // 1. éªŒè¯é…ç½®å‚æ•°
    ret = wifi_validate_network_config(config);
    if (ret < 0)
        return ret;
    
    // 2. åŠ å¯†æ•æ„Ÿä¿¡æ¯
    ret = wifi_encrypt_network_config(config);
    if (ret < 0)
        return ret;
    
    // 3. ä¿å­˜åˆ°æ•°æ®åº“
    ret = wifi_database_save_network(database, config);
    if (ret < 0)
        return ret;
    
    // 4. æ›´æ–°wpa_supplicanté…ç½®
    ret = wifi_update_wpa_config(app, config);
    if (ret < 0) {
        // å›æ»šæ•°æ®åº“æ“ä½œ
        wifi_database_remove_network(database, config->ssid);
        return ret;
    }
    
    // 5. é‡æ–°åŠ è½½wpa_supplicant
    ret = wifi_reload_wpa_supplicant(app);
    if (ret < 0)
        return ret;
    
    // 6. å‘é€é…ç½®æ›´æ–°äº‹ä»¶
    wifi_send_ui_event(app, WIFI_UI_EVENT_NETWORK_SAVED);
    
    return 0;
}
```

##### 1.4.2 è“ç‰™é…ç½®ç®¡ç†
```c
// è“ç‰™é…ç½®ç»“æ„
struct bluetooth_config {
    // åŸºç¡€é…ç½®
    char device_name[32];
    bool discoverable;
    bool pairable;
    int discoverable_timeout;
    int pairable_timeout;
    
    // å®‰å…¨é…ç½®
    bool secure_simple_pairing;
    bool low_energy_security;
    int io_capability;
    
    // æœåŠ¡é…ç½®
    struct list_head enabled_services;
    struct list_head disabled_services;
    
    // è¿æ¥é…ç½®
    int max_connections;
    int connection_timeout;
    int inquiry_timeout;
};

// è“ç‰™é…ç½®ç®¡ç†APP
static int bluetooth_config_app_update(struct bluetooth_manager_app *app,
                                      struct bluetooth_config *config)
{
    int ret;
    struct bluetooth_database *database = app->database;
    
    // 1. éªŒè¯é…ç½®å‚æ•°
    ret = bluetooth_validate_config(config);
    if (ret < 0)
        return ret;
    
    // 2. ä¿å­˜é…ç½®åˆ°æ•°æ®åº“
    ret = bluetooth_database_save_config(database, config);
    if (ret < 0)
        return ret;
    
    // 3. æ›´æ–°è“ç‰™åè®®æ ˆé…ç½®
    ret = bluetooth_update_stack_config(app, config);
    if (ret < 0) {
        // å›æ»šæ•°æ®åº“æ“ä½œ
        bluetooth_database_restore_config(database);
        return ret;
    }
    
    // 4. é‡å¯è“ç‰™æœåŠ¡
    ret = bluetooth_restart_service(app);
    if (ret < 0)
        return ret;
    
    // 5. å‘é€é…ç½®æ›´æ–°äº‹ä»¶
    bluetooth_send_ui_event(app, BT_UI_EVENT_CONFIG_UPDATED);
    
    return 0;
}
```

#### 1.5 åŸºç¡€åŠŸèƒ½æµ‹è¯•è¯¦ç»†æ‹†è§£

##### 1.5.1 WiFiåŠŸèƒ½æµ‹è¯•
```c
// WiFiåŠŸèƒ½æµ‹è¯•å¥—ä»¶
struct wifi_test_suite {
    struct wifi_manager_app *app;
    struct wifi_test_results *results;
    struct wifi_test_config *config;
    
    // æµ‹è¯•ç”¨ä¾‹
    struct list_head test_cases;
    int total_tests;
    int passed_tests;
    int failed_tests;
};

// WiFiè¿æ¥æµ‹è¯•
static int wifi_test_connection(struct wifi_test_suite *test_suite)
{
    int ret;
    struct wifi_network_config *test_config;
    struct wifi_test_case *test_case;
    
    // 1. åˆ›å»ºæµ‹è¯•ç”¨ä¾‹
    test_case = wifi_create_test_case("WiFi Connection Test");
    if (!test_case)
        return -ENOMEM;
    
    // 2. è®¾ç½®æµ‹è¯•é…ç½®
    test_config = wifi_create_test_network_config();
    if (!test_config) {
        wifi_destroy_test_case(test_case);
        return -ENOMEM;
    }
    
    // 3. æ‰§è¡Œè¿æ¥æµ‹è¯•
    ret = wifi_connect_to_network(test_suite->app, test_config);
    if (ret < 0) {
        wifi_test_case_set_result(test_case, WIFI_TEST_FAILED, "Connection failed");
        goto out;
    }
    
    // 4. éªŒè¯è¿æ¥çŠ¶æ€
    ret = wifi_verify_connection(test_suite->app);
    if (ret < 0) {
        wifi_test_case_set_result(test_case, WIFI_TEST_FAILED, "Connection verification failed");
        goto out;
    }
    
    // 5. æµ‹è¯•æ•°æ®ä¼ è¾“
    ret = wifi_test_data_transfer(test_suite->app);
    if (ret < 0) {
        wifi_test_case_set_result(test_case, WIFI_TEST_FAILED, "Data transfer failed");
        goto out;
    }
    
    // 6. è®¾ç½®æµ‹è¯•é€šè¿‡
    wifi_test_case_set_result(test_case, WIFI_TEST_PASSED, "All tests passed");
    
out:
    // 7. æ¸…ç†æµ‹è¯•ç¯å¢ƒ
    wifi_disconnect_from_network(test_suite->app);
    wifi_destroy_test_network_config(test_config);
    
    // 8. æ·»åŠ åˆ°æµ‹è¯•ç»“æœ
    wifi_test_suite_add_case(test_suite, test_case);
    
    return ret;
}
```

##### 1.5.2 è“ç‰™åŠŸèƒ½æµ‹è¯•
```c
// è“ç‰™åŠŸèƒ½æµ‹è¯•å¥—ä»¶
struct bluetooth_test_suite {
    struct bluetooth_manager_app *app;
    struct bluetooth_test_results *results;
    struct bluetooth_test_config *config;
    
    // æµ‹è¯•ç”¨ä¾‹
    struct list_head test_cases;
    int total_tests;
    int passed_tests;
    int failed_tests;
};

// è“ç‰™æ‰«ææµ‹è¯•
static int bluetooth_test_scanning(struct bluetooth_test_suite *test_suite)
{
    int ret;
    struct bluetooth_test_case *test_case;
    
    // 1. åˆ›å»ºæµ‹è¯•ç”¨ä¾‹
    test_case = bluetooth_create_test_case("Bluetooth Scanning Test");
    if (!test_case)
        return -ENOMEM;
    
    // 2. å¯åŠ¨æ‰«æ
    ret = bluetooth_start_scan(test_suite->app);
    if (ret < 0) {
        bluetooth_test_case_set_result(test_case, BT_TEST_FAILED, "Scan start failed");
        goto out;
    }
    
    // 3. ç­‰å¾…æ‰«æå®Œæˆ
    ret = wait_for_completion_timeout(&test_suite->app->device_list->scan_completion, 30000);
    if (ret == 0) {
        bluetooth_test_case_set_result(test_case, BT_TEST_FAILED, "Scan timeout");
        goto out;
    }
    
    // 4. éªŒè¯æ‰«æç»“æœ
    ret = bluetooth_verify_scan_results(test_suite->app);
    if (ret < 0) {
        bluetooth_test_case_set_result(test_case, BT_TEST_FAILED, "Scan results verification failed");
        goto out;
    }
    
    // 5. è®¾ç½®æµ‹è¯•é€šè¿‡
    bluetooth_test_case_set_result(test_case, BT_TEST_PASSED, "Scan test passed");
    
out:
    // 6. åœæ­¢æ‰«æ
    bluetooth_stop_scan(test_suite->app);
    
    // 7. æ·»åŠ åˆ°æµ‹è¯•ç»“æœ
    bluetooth_test_suite_add_case(test_suite, test_case);
    
    return ret;
}
```

#### 1.6 ç½‘ç»œé…ç½®è¯¦ç»†æ‹†è§£

##### 1.6.1 ç½‘ç»œæ¥å£é…ç½®
```c
// ç½‘ç»œæ¥å£é…ç½®ç»“æ„
struct network_interface_config {
    char interface_name[16];
    enum network_type type;
    bool enabled;
    
    // IPé…ç½®
    enum ip_config_method ip_method;
    char ip_address[16];
    char netmask[16];
    char gateway[16];
    char dns_servers[64];
    
    // DHCPé…ç½®
    bool dhcp_enabled;
    char dhcp_hostname[64];
    int dhcp_timeout;
    
    // è·¯ç”±é…ç½®
    struct list_head static_routes;
    
    // é˜²ç«å¢™é…ç½®
    struct firewall_config *firewall;
};

// ç½‘ç»œé…ç½®ç®¡ç†APP
static int network_config_app_apply(struct wifi_manager_app *app,
                                   struct network_interface_config *config)
{
    int ret;
    
    // 1. éªŒè¯é…ç½®å‚æ•°
    ret = network_validate_interface_config(config);
    if (ret < 0)
        return ret;
    
    // 2. åœæ­¢ç½‘ç»œæ¥å£
    ret = network_stop_interface(config->interface_name);
    if (ret < 0)
        return ret;
    
    // 3. é…ç½®IPåœ°å€
    if (config->ip_method == IP_CONFIG_STATIC) {
        ret = network_configure_static_ip(config);
    } else {
        ret = network_configure_dhcp(config);
    }
    if (ret < 0)
        goto err_ip_config;
    
    // 4. é…ç½®è·¯ç”±
    ret = network_configure_routes(config);
    if (ret < 0)
        goto err_route_config;
    
    // 5. é…ç½®é˜²ç«å¢™
    ret = network_configure_firewall(config);
    if (ret < 0)
        goto err_firewall_config;
    
    // 6. å¯åŠ¨ç½‘ç»œæ¥å£
    ret = network_start_interface(config->interface_name);
    if (ret < 0)
        goto err_start_interface;
    
    // 7. éªŒè¯ç½‘ç»œè¿æ¥
    ret = network_verify_connectivity(config);
    if (ret < 0)
        goto err_connectivity;
    
    // 8. å‘é€é…ç½®åº”ç”¨äº‹ä»¶
    network_send_ui_event(app, NETWORK_UI_EVENT_CONFIG_APPLIED);
    
    return 0;
    
err_connectivity:
    network_stop_interface(config->interface_name);
err_start_interface:
    network_clear_firewall(config);
err_firewall_config:
    network_clear_routes(config);
err_route_config:
    network_clear_ip_config(config);
err_ip_config:
    network_start_interface(config->interface_name);
    return ret;
}
```

##### 1.6.2 ç½‘ç»œæœåŠ¡é…ç½®
```c
// ç½‘ç»œæœåŠ¡é…ç½®ç»“æ„
struct network_service_config {
    char service_name[32];
    enum network_service_type type;
    bool enabled;
    int port;
    
    // æœåŠ¡é…ç½®
    struct list_head parameters;
    struct list_head access_control;
    
    // ç›‘æ§é…ç½®
    bool monitoring_enabled;
    int health_check_interval;
    int max_failures;
    
    // æ—¥å¿—é…ç½®
    bool logging_enabled;
    char log_file[256];
    int log_level;
};

// ç½‘ç»œæœåŠ¡ç®¡ç†APP
static int network_service_app_start(struct wifi_manager_app *app,
                                    struct network_service_config *config)
{
    int ret;
    
    // 1. éªŒè¯æœåŠ¡é…ç½®
    ret = network_validate_service_config(config);
    if (ret < 0)
        return ret;
    
    // 2. æ£€æŸ¥ç«¯å£å¯ç”¨æ€§
    ret = network_check_port_availability(config->port);
    if (ret < 0)
        return ret;
    
    // 3. å¯åŠ¨ç½‘ç»œæœåŠ¡
    ret = network_start_service(config);
    if (ret < 0)
        return ret;
    
    // 4. é…ç½®è®¿é—®æ§åˆ¶
    ret = network_configure_access_control(config);
    if (ret < 0)
        goto err_access_control;
    
    // 5. å¯åŠ¨æœåŠ¡ç›‘æ§
    if (config->monitoring_enabled) {
        ret = network_start_service_monitoring(config);
        if (ret < 0)
            goto err_monitoring;
    }
    
    // 6. é…ç½®æ—¥å¿—è®°å½•
    if (config->logging_enabled) {
        ret = network_configure_service_logging(config);
        if (ret < 0)
            goto err_logging;
    }
    
    // 7. å‘é€æœåŠ¡å¯åŠ¨äº‹ä»¶
    network_send_ui_event(app, NETWORK_UI_EVENT_SERVICE_STARTED);
    
    return 0;
    
err_logging:
    if (config->monitoring_enabled)
        network_stop_service_monitoring(config);
err_monitoring:
    network_clear_access_control(config);
err_access_control:
    network_stop_service(config);
    return ret;
}
```

---

## ğŸ“‹ åŸºç¡€æ¶æ„å¼€å‘æ£€æŸ¥æ¸…å•

### Week 1-2: ç¯å¢ƒæ­å»ºå’Œé©±åŠ¨å¼€å‘
- [ ] äº¤å‰ç¼–è¯‘ç¯å¢ƒé…ç½®
- [ ] å†…æ ¸æºç ä¸‹è½½å’Œé…ç½®
- [ ] WiFié©±åŠ¨æ¡†æ¶æ­å»º
- [ ] è“ç‰™é©±åŠ¨æ¡†æ¶æ­å»º
- [ ] åŸºç¡€é©±åŠ¨åŠŸèƒ½æµ‹è¯•

### Week 3-4: åŸºç¡€åŠŸèƒ½å®ç°å’Œç½‘ç»œé…ç½®
- [ ] WiFiæ‰«æåŠŸèƒ½å®ç°
- [ ] WiFiè¿æ¥åŠŸèƒ½å®ç°
- [ ] BLEæ‰«æåŠŸèƒ½å®ç°
- [ ] GATTæœåŠ¡å®ç°
- [ ] ç½‘ç»œæ¥å£é…ç½®
- [ ] åŸºç¡€åŠŸèƒ½æµ‹è¯•å®Œæˆ

### æŠ€æœ¯è¦ç‚¹æ£€æŸ¥
- [ ] é©±åŠ¨æ¶æ„è®¾è®¡åˆç†
- [ ] é”™è¯¯å¤„ç†æœºåˆ¶å®Œå–„
- [ ] å†…å­˜ç®¡ç†å®‰å…¨
- [ ] å¹¶å‘è®¿é—®æ§åˆ¶
- [ ] ç”µæºç®¡ç†æ”¯æŒ
- [ ] è°ƒè¯•æ¥å£å®Œå–„

### ä»£ç è´¨é‡æ£€æŸ¥
- [ ] ä»£ç é£æ ¼è§„èŒƒ
- [ ] æ³¨é‡Šå®Œæ•´æ¸…æ™°
- [ ] é”™è¯¯ç å®šä¹‰åˆç†
- [ ] æ—¥å¿—è®°å½•å®Œå–„
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡
